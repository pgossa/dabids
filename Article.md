## A Simple Tutorial on Building a GraphQL API in Go using gqlgen and Gorm

## Introduction

In this tutorial, we will walk you through the process of building a powerful and efficient API using gqlgen and GORM in Go. gqlgen is a popular Go library that helps you generate type-safe GraphQL servers, and GORM is a feature-rich ORM (Object-Relational Mapping) library for Go.

By combining gqlgen and GORM, we can leverage the benefits of GraphQL's flexible querying and mutation capabilities along with the ease of working with databases using GORM. This combination allows us to rapidly develop APIs with strong type safety and efficient data retrieval.

Throughout this tutorial, we will cover the following key topics:

  * Setting up the project: We'll start by initializing a new Go project and installing the necessary dependencies, including gqlgen and GORM.
  * Defining the GraphQL schema: We'll create a schema definition file that specifies the structure and behavior of our API, including the types, queries, and mutations.
  * Generating Go code with gqlgen: We'll use gqlgen to automatically generate Go code based on our schema definition. This code will provide the foundations of our GraphQL server.
  * Implementing resolvers: We'll write the resolver functions that handle the GraphQL queries and mutations defined in our schema. These resolvers will interact with the database using GORM to fetch and manipulate the data.
  * Testing the API: We'll demonstrate how to test our API using tools like Postman or GraphQL playgrounds to validate that our resolvers work as expected.

By the end of this tutorial, you will have a solid understanding of how to create a Go API with gqlgen and GORM, enabling you to build scalable and performant GraphQL servers that seamlessly integrate with your database.
So, let's get started with setting up our project and dive into the world of Go, gqlgen, and GORM!

Note: This tutorial assumes you have basic knowledge of Go programming language and have Go and its package manager, Go modules, set up on your system.

## Getting started

Our first step is to create out project folder:
```bash
mkdir dabids
cd dabids
go mod init dabids
```

Next, let's initialize our project using gqlgen:
```bash
go run github.com/99designs/gqlgen init
```

Now we will make some changes to the project's structure (as I find that the default structure is only a few big files).

So first let's delete everything inside the ```graph/``` folder as we will rearange the structure.
And let's modify the ```gqlgen.yml```:
```yaml
# /gqlgen.yml

# Where are all the schema files located? globs are supported eg  src/**/*.graphqls
schema:
  - graph/typeDefs/*.gql

# Where should the generated server code go?
exec:
  filename: graph/generated/generated.go
  package: generated

# Where should any generated models go?
model:
  filename: graph/customTypes/types_gen.go
  package: customTypes

# Where should the resolver implementations go?
resolver:
  layout: follow-schema
  dir: graph/resolvers
  package: resolvers
  filename_template: "{name}.resolver.go"
autobind:
#  - "dabids/graph/model"
models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
  Int:
    model:
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
```

So with these settings we are storing all our schema files inside ```graph/typeDefs```\
Our resolvers will be inside ```graph/resolvers```\
All the generated files from gqlgen will be stored inside ```graph/generated```\
And the generated types by gqlgen will be under ```graph/customTypes```

### Schemas

Now that our project is setted up we will create a few schemas, but first let's use a quick workaround:\
gqlgen does not allow us to separate our schema which result in a big file containing all our schemas which can grow really big,\
So the tricks is to first define 2 files which will define our ```Query``` and ```Mutation``` and then to extend that type in every other schema:\
*Note: The filenames begin with a 0 to be parsed first by gqlgen*
```go
# graph/typeDefs/0Mutation.gql
type Mutation {
  version: String!
}
```
```go
# graph/typeDefs/0Query.gql
type Query {
  version: String!
}
```
```go
# graph/typeDefs/User.gql
type User {
  id: ID!
  username: String!
  password: String!
}

extend type Query {
  easyUser: String!
}

extend type Mutation {
  easyUser: String!
}
```

## CheckPoint I

With only these schemas and the ```server.go``` generated by gqlgen we are able to run:\
```bash
go run github.com/99designs/gqlgen generate
```
This will generate the gqlgen logic and we just have to modify the generated ```graph/resolvers/User.resolver.go``` like:
```go
package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"fmt"
)

// EasyUser is the resolver for the easyUser field.
func (r *mutationResolver) EasyUser(ctx context.Context) (string, error) {
	return "Mutate User", nil
}

// EasyUser is the resolver for the easyUser field.
func (r *queryResolver) EasyUser(ctx context.Context) (string, error) {
	return "Query User", nil
}
```

So now we can run the server: ```go run server.go```\
The graphql playground is accessible at http://localhost:8080 and you can run the mutation/query:
```
mutation {
  easyUser
}
```
and
```
query {
  easyUser
}
```
Which should return you "Mutate User" and "Query User"

## Database

Our app is now functional but pretty useless so let's add/modify the schemas:\
```
```
